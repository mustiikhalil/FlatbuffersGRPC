// automatically generated by the FlatBuffers compiler, do not modify

import FlatBuffers

public struct Point: FlatBufferObject {

    static func validateVersion() { FlatBuffersVersion_1_12_0() }
    public var __buffer: ByteBuffer! { return _accessor.bb }
    private var _accessor: Table

    public static func getRootAsPoint(bb: ByteBuffer) -> Point { return Point(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

    private init(_ t: Table) { _accessor = t }
    public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

    enum VTOFFSET: VOffset {
        case latitude = 4
        case longitude = 6
        var v: Int32 { Int32(self.rawValue) }
        var p: VOffset { self.rawValue }
    }

    public var latitude: Int32 { let o = _accessor.offset(VTOFFSET.latitude.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
    public var longitude: Int32 { let o = _accessor.offset(VTOFFSET.longitude.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
    public static func startPoint(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
    public static func add(latitude: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: latitude, def: 0, at: VTOFFSET.latitude.p) }
    public static func add(longitude: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: longitude, def: 0, at: VTOFFSET.longitude.p) }
    public static func endPoint(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
    public static func createPoint(_ fbb: inout FlatBufferBuilder,
    latitude: Int32 = 0,
    longitude: Int32 = 0) -> Offset<UOffset> {
        let __start = Point.startPoint(&fbb)
        Point.add(latitude: latitude, &fbb)
        Point.add(longitude: longitude, &fbb)
        return Point.endPoint(&fbb, start: __start)
    }
}

public struct Rectangle: FlatBufferObject {

    static func validateVersion() { FlatBuffersVersion_1_12_0() }
    public var __buffer: ByteBuffer! { return _accessor.bb }
    private var _accessor: Table

    public static func getRootAsRectangle(bb: ByteBuffer) -> Rectangle { return Rectangle(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

    private init(_ t: Table) { _accessor = t }
    public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

    enum VTOFFSET: VOffset {
        case lo = 4
        case hi = 6
        var v: Int32 { Int32(self.rawValue) }
        var p: VOffset { self.rawValue }
    }

    public var lo: Point? { let o = _accessor.offset(VTOFFSET.lo.v); return o == 0 ? nil : Point(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
    public var hi: Point? { let o = _accessor.offset(VTOFFSET.hi.v); return o == 0 ? nil : Point(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
    public static func startRectangle(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
    public static func add(lo: Offset<UOffset>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lo, at: VTOFFSET.lo.p)  }
    public static func add(hi: Offset<UOffset>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hi, at: VTOFFSET.hi.p)  }
    public static func endRectangle(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
    public static func createRectangle(_ fbb: inout FlatBufferBuilder,
    offsetOfLo lo: Offset<UOffset> = Offset(),
    offsetOfHi hi: Offset<UOffset> = Offset()) -> Offset<UOffset> {
        let __start = Rectangle.startRectangle(&fbb)
        Rectangle.add(lo: lo, &fbb)
        Rectangle.add(hi: hi, &fbb)
        return Rectangle.endRectangle(&fbb, start: __start)
    }
}

public struct Feature: FlatBufferObject {

    static func validateVersion() { FlatBuffersVersion_1_12_0() }
    public var __buffer: ByteBuffer! { return _accessor.bb }
    private var _accessor: Table

    public static func getRootAsFeature(bb: ByteBuffer) -> Feature { return Feature(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

    private init(_ t: Table) { _accessor = t }
    public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

    enum VTOFFSET: VOffset {
        case name = 4
        case location = 6
        var v: Int32 { Int32(self.rawValue) }
        var p: VOffset { self.rawValue }
    }

    public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
    public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
    public var location: Point? { let o = _accessor.offset(VTOFFSET.location.v); return o == 0 ? nil : Point(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
    public static func startFeature(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
    public static func add(name: Offset<String>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p)  }
    public static func add(location: Offset<UOffset>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: location, at: VTOFFSET.location.p)  }
    public static func endFeature(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
    public static func createFeature(_ fbb: inout FlatBufferBuilder,
    offsetOfName name: Offset<String> = Offset(),
    offsetOfLocation location: Offset<UOffset> = Offset()) -> Offset<UOffset> {
        let __start = Feature.startFeature(&fbb)
        Feature.add(name: name, &fbb)
        Feature.add(location: location, &fbb)
        return Feature.endFeature(&fbb, start: __start)
    }
}

public struct Features: FlatBufferObject {

    static func validateVersion() { FlatBuffersVersion_1_12_0() }
    public var __buffer: ByteBuffer! { return _accessor.bb }
    private var _accessor: Table

    public static func getRootAsFeatures(bb: ByteBuffer) -> Features { return Features(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

    private init(_ t: Table) { _accessor = t }
    public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

    enum VTOFFSET: VOffset {
        case feature = 4
        var v: Int32 { Int32(self.rawValue) }
        var p: VOffset { self.rawValue }
    }

    public var featureCount: Int32 { let o = _accessor.offset(VTOFFSET.feature.v); return o == 0 ? 0 : _accessor.vector(count: o) }
    public func feature(at index: Int32) -> Feature? { let o = _accessor.offset(VTOFFSET.feature.v); return o == 0 ? nil : Feature(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
    public static func startFeatures(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
    public static func addVectorOf(feature: Offset<UOffset>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: feature, at: VTOFFSET.feature.p)  }
    public static func endFeatures(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
    public static func createFeatures(_ fbb: inout FlatBufferBuilder,
    vectorOfFeature feature: Offset<UOffset> = Offset()) -> Offset<UOffset> {
        let __start = Features.startFeatures(&fbb)
        Features.addVectorOf(feature: feature, &fbb)
        return Features.endFeatures(&fbb, start: __start)
    }
}

public struct RouteNote: FlatBufferObject {

    static func validateVersion() { FlatBuffersVersion_1_12_0() }
    public var __buffer: ByteBuffer! { return _accessor.bb }
    private var _accessor: Table

    public static func getRootAsRouteNote(bb: ByteBuffer) -> RouteNote { return RouteNote(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

    private init(_ t: Table) { _accessor = t }
    public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

    enum VTOFFSET: VOffset {
        case location = 4
        case message = 6
        var v: Int32 { Int32(self.rawValue) }
        var p: VOffset { self.rawValue }
    }

    public var location: Point? { let o = _accessor.offset(VTOFFSET.location.v); return o == 0 ? nil : Point(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
    public var message: String? { let o = _accessor.offset(VTOFFSET.message.v); return o == 0 ? nil : _accessor.string(at: o) }
    public var messageSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.message.v) }
    public static func startRouteNote(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
    public static func add(location: Offset<UOffset>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: location, at: VTOFFSET.location.p)  }
    public static func add(message: Offset<String>, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: message, at: VTOFFSET.message.p)  }
    public static func endRouteNote(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
    public static func createRouteNote(_ fbb: inout FlatBufferBuilder,
    offsetOfLocation location: Offset<UOffset> = Offset(),
    offsetOfMessage message: Offset<String> = Offset()) -> Offset<UOffset> {
        let __start = RouteNote.startRouteNote(&fbb)
        RouteNote.add(location: location, &fbb)
        RouteNote.add(message: message, &fbb)
        return RouteNote.endRouteNote(&fbb, start: __start)
    }
}

public struct RouteSummary: FlatBufferObject {

    static func validateVersion() { FlatBuffersVersion_1_12_0() }
    public var __buffer: ByteBuffer! { return _accessor.bb }
    private var _accessor: Table

    public static func getRootAsRouteSummary(bb: ByteBuffer) -> RouteSummary { return RouteSummary(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

    private init(_ t: Table) { _accessor = t }
    public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

    enum VTOFFSET: VOffset {
        case pointCount = 4
        case featureCount = 6
        case distance = 8
        case elapsedTime = 10
        var v: Int32 { Int32(self.rawValue) }
        var p: VOffset { self.rawValue }
    }

    public var pointCount: Int32 { let o = _accessor.offset(VTOFFSET.pointCount.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
    public var featureCount: Int32 { let o = _accessor.offset(VTOFFSET.featureCount.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
    public var distance: Int32 { let o = _accessor.offset(VTOFFSET.distance.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
    public var elapsedTime: Int32 { let o = _accessor.offset(VTOFFSET.elapsedTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
    public static func startRouteSummary(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
    public static func add(pointCount: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pointCount, def: 0, at: VTOFFSET.pointCount.p) }
    public static func add(featureCount: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: featureCount, def: 0, at: VTOFFSET.featureCount.p) }
    public static func add(distance: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: distance, def: 0, at: VTOFFSET.distance.p) }
    public static func add(elapsedTime: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: elapsedTime, def: 0, at: VTOFFSET.elapsedTime.p) }
    public static func endRouteSummary(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
    public static func createRouteSummary(_ fbb: inout FlatBufferBuilder,
    pointCount: Int32 = 0,
    featureCount: Int32 = 0,
    distance: Int32 = 0,
    elapsedTime: Int32 = 0) -> Offset<UOffset> {
        let __start = RouteSummary.startRouteSummary(&fbb)
        RouteSummary.add(pointCount: pointCount, &fbb)
        RouteSummary.add(featureCount: featureCount, &fbb)
        RouteSummary.add(distance: distance, &fbb)
        RouteSummary.add(elapsedTime: elapsedTime, &fbb)
        return RouteSummary.endRouteSummary(&fbb, start: __start)
    }
}

